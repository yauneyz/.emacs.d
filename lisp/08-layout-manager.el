;;; 08-layout-manager.el --- Save and restore window layouts -*- lexical-binding: t; -*-

;;; Commentary:
;; This package provides functionality to save and restore window layouts
;; including projectile project context, window arrangements, and open files.

;;; Code:


(defvar layout-manager-directory
  (expand-file-name "layouts" user-emacs-directory)
  "Directory where layout files are stored.")

(defun layout--ensure-layouts-directory ()
  "Ensure the layouts directory exists, creating it if necessary."
  (unless (file-exists-p layout-manager-directory)
    (make-directory layout-manager-directory t)))

(defun layout--capture-window-info (window)
  "Capture information about a single WINDOW."
  (let ((buffer (window-buffer window))
        (edges (window-pixel-edges window)))
    (list :type 'window
          :buffer-name (buffer-name buffer)
          :file (buffer-file-name buffer)
          :edges edges
          :width (window-total-width window)
          :height (window-total-height window))))

(defun layout--capture-window-tree (&optional window)
  "Recursively capture the window tree starting from WINDOW (or root if nil)."
  (let ((tree (window-tree window)))
    (if (windowp tree)
        ;; Single window
        (layout--capture-window-info tree)
      ;; Split container
      (let ((direction (car tree))
            (children (cddr tree)))
        (list :type 'split
              :direction (if direction 'horizontal 'vertical)
              :children (mapcar #'layout--capture-window-tree children))))))

(defun layout--restore-window (window-info)
  "Restore a single window from WINDOW-INFO."
  (let ((file (plist-get window-info :file))
        (buffer-name (plist-get window-info :buffer-name)))
    (cond
     ;; If we have a file, open it
     (file
      (if (file-exists-p file)
          (find-file file)
        (message "File no longer exists: %s" file)
        (get-buffer-create buffer-name)))
     ;; Otherwise try to get the buffer by name
     (buffer-name
      (or (get-buffer buffer-name)
          (get-buffer-create buffer-name)))
     ;; Fallback to scratch buffer
     (t (get-buffer-create "*scratch*")))))

(defun layout--restore-window-tree (tree-info &optional window)
  "Recursively restore window tree from TREE-INFO in WINDOW (or current if nil)."
  (let ((type (plist-get tree-info :type)))
    (cond
     ((eq type 'window)
      ;; Single window - restore the buffer
      (let ((buffer (layout--restore-window tree-info)))
        (when buffer
          (set-window-buffer (or window (selected-window)) buffer))))
     
     ((eq type 'split)
      ;; Split container - create splits and restore children
      (let* ((direction (plist-get tree-info :direction))
             (children (plist-get tree-info :children))
             (current-window (or window (selected-window)))
             (vertical-split (eq direction 'vertical)))
        
        ;; Restore first child in current window
        (when (car children)
          (layout--restore-window-tree (car children) current-window))
        
        ;; Create splits for remaining children
        (dolist (child (cdr children))
          (let ((new-window (split-window current-window nil vertical-split)))
            (layout--restore-window-tree child new-window)
            (setq current-window new-window))))))))

;;;###autoload
(defun layout-save (layout-name)
  "Save the current window layout with LAYOUT-NAME."
  (interactive "sLayout name: ")
  (layout--ensure-layouts-directory)
  (let* ((project-root (when (projectile-project-p)
                         (projectile-project-root)))
         (window-tree (layout--capture-window-tree))
         (layout-data (list :project-root project-root
                           :window-tree window-tree
                           :timestamp (format-time-string "%Y-%m-%dT%H:%M:%S")
                           :emacs-version emacs-version))
         (filename (expand-file-name (concat layout-name ".el") 
                                    layout-manager-directory)))
    
    (with-temp-file filename
      (insert ";;; Layout data generated by layout-manager\n")
      (insert ";; Do not edit this file manually\n\n")
      (print layout-data (current-buffer)))
    
    (message "Layout '%s' saved to %s" layout-name filename)))

(defun layout--get-saved-layouts ()
  "Get list of saved layout names."
  (when (file-exists-p layout-manager-directory)
    (mapcar (lambda (file)
              (file-name-sans-extension file))
            (directory-files layout-manager-directory nil "\\.el$"))))

;;;###autoload
(defun layout-load ()
  "Load a saved window layout."
  (interactive)
  (let ((layouts (layout--get-saved-layouts)))
    (if (not layouts)
        (message "No saved layouts found")
      (let* ((layout-name (if (and (boundp 'ivy-mode) ivy-mode)
                             (ivy-completing-read "Load layout: " layouts)
                           (completing-read "Load layout: " layouts nil t)))
             (filename (expand-file-name (concat layout-name ".el")
                                        layout-manager-directory)))
        
        (if (not (file-exists-p filename))
            (message "Layout file not found: %s" filename)
          
          ;; Read and parse the layout data
          (let ((layout-data (with-temp-buffer
                              (insert-file-contents filename)
                              ;; Skip to the data part (after comments)
                              (goto-char (point-min))
                              (while (looking-at "^;;")
                                (forward-line))
                              (read (current-buffer)))))
            
            ;; Clear current windows
            (delete-other-windows)
            
            ;; Switch to project if specified
            (let ((project-root (plist-get layout-data :project-root)))
              (when (and project-root (file-exists-p project-root))
                (projectile-switch-project-by-name project-root)))
            
            ;; Restore window layout
            (let ((window-tree (plist-get layout-data :window-tree)))
              (when window-tree
                (layout--restore-window-tree window-tree)))
            
            (message "Layout '%s' loaded" layout-name)))))))

(provide '08-layout-manager)
;;; 08-layout-manager.el ends here
